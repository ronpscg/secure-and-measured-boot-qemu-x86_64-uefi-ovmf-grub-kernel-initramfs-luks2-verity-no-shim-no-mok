#!/bin/bash
# dev script to wrap some stuff

LOCAL_DIR=$(dirname $(readlink -f ${BASH_SOURCE[0]}))
SCRIPTS_DIR=$(readlink -f $LOCAL_DIR/..)
export COMMON_CONFIG_FILE
: ${COMMON_CONFIG_FILE:=$LOCAL_DIR/bitbake.env}

# Could run bitbake -e and get some environment variables, but I won't do that
: ${YOCTO_BUILD_DIR=$HOME/yocto/build-scarthgap-x86_64}
: ${MACHINE=genericx86-64}
: ${IMAGE_BASENAME=signing-wip}



TOPDIR=${YOCTO_BUILD_DIR}
DEPLOY_DIR=${TOPDIR}/tmp/deploy
DEPLOY_DIR_IMAGE=${DEPLOY_DIR}/images/${MACHINE}
SECURE_ARTIFACTS_BASE_SYMLINK="${DEPLOY_DIR_IMAGE}/secure-boot-work"
SECURE_ARTIFACTS_BASE_REALPATH=$(readlink -f $SECURE_ARTIFACTS_BASE_SYMLINK)
export SECURE_ARTIFACTS_BASE_SYMLINK # not sure the exporting is needed, we'll see as I port on

# This is the rootfs unpacked. We can use it to pack it ourselves, as a rootfs step for the images we would like to create
: ${IMAGE_ROOTFS="${TOPDIR}/tmp/work/${MACHINE}-poky-linux/${IMAGE_BASENAME}/1.0/rootfs"}

# Depending on the image type, this would be the prefix of the link (the target is with date and time) to the .wic, ext4 (not generated by default) etc.
: ${IMAGE_LINK_NAME="${IMAGE_BASENAME}-${MACHINE}.rootfs"} 

: ${INITRAMFS_FSTYPES="cpio.gz"}
: ${INITRAMFS_IMAGE="${IMAGE_BASENAME}-initramfs"}
: ${INITRAMFS_IMAGE_NAME="${IMAGE_BASENAME}-${MACHINE}"}

: ${KERNEL_IMAGETYPE="bzImage"}


: ${EFI_PROVIDER="grub-efi"}
: ${EFI_BOOT_IMAGE="bootx64.efi"}
GRUB_IMAGE=${EFI_PROVIDER}-${EFI_BOOT_IMAGE}

set -euo pipefail

error_exit=false
if [ ! -d "$DEPLOY_DIR_IMAGE" ] ; then
	echo -e "\e[31m$DEPLOY_DIR_IMAGE does not exist" 
	error_exit=true	
fi
if [ ! -d "$SECURE_ARTIFACTS_BASE_REALPATH" ] ; then
	echo -e "\e[31m$SECURE_ARTIFACTS_BASE_REALPATH does not exist"
	error_exit=true
fi

if [ "$error_exit" = "true" ] ; then
	echo "Please assure you built, and provided the right YOCTO_BUILD_DIR and MACHINE and IMAGE_BASENAME variables."
	echo "You provided: YOCTO_BUILD_DIR=$YOCTO_BUILD_DIR MACHINE=$MACHINE IMAGE_BASENAME=$IMAGE_BASENAME"
	exit 1
fi

#---------------------------------------------------------------------------
# Copy from the Yocto deploy dir to the workdir
# (this logic will be used for post processing on Yocto Project as well)
#---------------------------------------------------------------------------
echo -e "\e[42mWelcome $(date)\e[0m"
echo "Using $COMMON_CONFIG_FILE"
echo
echo -e "\e[31mBefore we begin copying:\e[0m"
. ${COMMON_CONFIG_FILE} # Only if we want to use some variables for debugging in this script, otherwise it is sourced from common.sh
set +e # don't error if the file did not exist
md5sum ${REQUIRED_PROJECTS_ARTIFACTS_DIR}/grub-efi-bootx64.efi 
set -e

T1=${REQUIRED_PROJECTS_ARTIFACTS_DIR}

CP_SRC_KERNEL=${DEPLOY_DIR_IMAGE}/${KERNEL_IMAGETYPE}
# We simplified the names, and for the dracut ramdisk we just call it initrd.img
#CP_SRC_INITRAMFS=${DEPLOY_DIR_IMAGE}/${INITRAMFS_IMAGE_NAME}.${INITRAMFS_FSTYPES}
CP_SRC_INITRAMFS=${DEPLOY_DIR_IMAGE}/initrd.img
CP_SRC_GRUB=${DEPLOY_DIR_IMAGE}/${GRUB_IMAGE}
cp $CP_SRC_KERNEL $T1/kernel
cp $CP_SRC_INITRAMFS $T1/initramfs

echo "Temporarily copying some other things over (the initramfs was built inside yocto, using docker)"
#CP_SRC_KERNEL=/home/ron/pscg/secureboot-qemu-x86_64-efi-grub/components/artifacts/bzImage
CP_SRC_INITRAMFS=${DEPLOY_DIR_IMAGE}/initrd.img
cp $CP_SRC_KERNEL $T1/kernel
cp $CP_SRC_INITRAMFS $T1/initramfs


: ${COPY_ROOTFS_=false}
#
# Note: if you are using the rootfs from yocto - it could very likely be under fakeroot - and it will not boot
# 
if [ "$COPY_ROOTFS_" = "true" ] ; then
	cp $CP_SRC_GRUB $T1/${GRUB_IMAGE}
	if [ -d $T1/rootfs ] ; then
		sudo rm -rf $T1/rootfs
	fi
	sudo cp -a ${IMAGE_ROOTFS} $T1/rootfs
	# if built with rootfs.img can copy it too, but for now it is not that important
	# will be more important inside the Yocto recipes themselves
fi

# ext4 must be enabled in your image types - or you must extract it from the created wic file otherwise (or alternatively: untar/unzip/extract the rootfs and kernel modules)
T2=${ARTIFACTS_DIR}
CP_SRC_ROOTFS_IMG=${DEPLOY_DIR_IMAGE}/${IMAGE_LINK_NAME}.ext4
cp $CP_SRC_ROOTFS_IMG  $T2/rootfs.img

#echo -e "\e[44mTemporarily copying grub.cfg\e[0m"
#cp $T1/../grub.cfg $T1 


# All below don't matter as they are set in the bitbake.env script.
if false ; then
T2=${ARTIFACTS_DIR}
KERNEL_ARTIFACT=$T1/kernel
INITRAMFS_ARTIFACT=$T1/initramfs
GRUB_ARTIFACT=$T1/${GRUB_IMAGE}
GRUB_CONFIG_ARTIFACT=$T1/grub.cfg
ROOTFS_FS_FOLDER=$T1/rootfs
fi

#--- without rootfs.img now ---

# Non Yocto name
# This is an example for working on the in tree (better with devtool, or not the cross-toolchain)
: ${KERNEL_ARTIFACT=/home/ron/yocto/build-scarthgap-x86_64/tmp/work/genericx86_64-poky-linux/linux-yocto/6.6.21+git/linux-genericx86_64-standard-build/arch/x86/boot/bzImage}

# Non Yocto name
# If there is only one INITRAMFS_FSTYPES - then this could be ${INITRAMFS_IMAGE}-${MACHINE}.${INITRAMFS_FSTYPES}
: ${INITRAMFS_ARTIFACT="${DEPLOY_DIR_IMAGE}/${INITRAMFS_IMAGE_NAME}.${INITRAMFS_FSTYPES}"}


echo -e "\e[32mAfter we begin copying:\e[0m"
md5sum ${REQUIRED_PROJECTS_ARTIFACTS_DIR}/grub-efi-bootx64.efi 
md5sum ${GRUB_ARTIFACT}
md5sum ${KERNEL_ARTIFACT}
md5sum ${INITRAMFS_ARTIFACT}
echo

export GRUB_CONFIGS="${LOCAL_DIR}/grub-templated.cfg"

# 
# Set an automatic value for the innocent people who just want to see this work
# The less innocent ones would set KERNEL_CMDLINE_CONSOLE explicitly
#
if [ -f /.dockerenv ] ; then
	: ${KERNEL_CMDLINE_CONSOLE=console=tty0 console=ttyS0}
else
	: ${KERNEL_CMDLINE_CONSOLE=console=ttS0 console=tty0}
fi
export KERNEL_CMDLINE_CONSOLE

#. $SCRIPTS_DIR/common.sh
export GRUB_DEFAULT_ENTRY=0
#cd $SCRIPTS_DIR/external-projects/
#./build-grub.sh update_grub_work_config
#)

cd $SCRIPTS_DIR/main
# if [ "$COPY_ROOTFS_" = "true" ] ; then
export DONT_RECREATE_ROOTFS=true 
./make-images-rootfs.sh
#fi
 
./make-images-boot-materials.sh
./make-combined-gpt-disk-image.sh
