#!/bin/bash
set -euo pipefail

setup() (
	# GRUB2 is ~107M after syncing (as per Nov 25 2025) and is cloned quite fast
	cd $REQUIRED_PROJECTS_DIR
	git clone https://git.savannah.gnu.org/git/grub.git
	cd $GRUB_BUILDER_DIR
	echo "Uwaga - Grub update in November broke the ./bootstrap script. Checking out the commit I last worked with that worked (for 2.14-rc1)"
	git checkout 2bc0929a2fffbb60995605db6ce46aa3f979a7d2 
	./bootstrap
)

build_grub_core() (
	cd $GRUB_BUILDER_DIR
	# takes a while but less than a minute
	./configure --with-platform=efi --target=x86_64
	# faster than the configure step
	make -j$(nproc)
	echo "Done building GRUB core"
)


# This uses grub-mkimage, which does not encapsulate the $GRUB_CONFIG in it.
# This is what you would want to do, for example, if you use Yocto Project and don't want to tinker around the recipes and add your own build step
# This is WIP - we could encapsulate very minimal config that would be read BEFORE modules are loaded (and does not support almost anything), using -c <config file>, which
# is basically what the Yocto project does but I won't do it now, it's WIP
#
build_nonstandalone_image() (
	echo -e "\x1b[43mWarning this has not been run/tested/etc., it's a preparation, for something I don't support\x1b[0m"

	cd $GRUB_BUILDER_DIR
	# grub-mkimage requires specifying modules explicitly
	# minicmd has help, lsmod etc. One could include help, but there is no module for lsmod
	: ${GRUB_MODULES="
		part_gpt part_msdos ext2 linux normal boot memdisk configfile search fat ls cat echo test gcry_dsa gcry_rsa gcry_sha256 pubkey pgp \
		tar minicmd efifwsetup
		tpm \
	"}
	: ${GRUB_TARGET_CONFIG_FILE_PREFIX_DIR="/EFI/Boot"}
	./grub-mkimage -O x86_64-efi -o grubx64.efi --directory=./grub-core \
		--disable-shim-lock \
		--pubkey=$GRUB_PGP_PUBLIC_KEY \
		--prefix=$GRUB_TARGET_CONFIG_FILE_PREFIX_DIR \
		$GRUB_MODULES
)

build_standalone_image_with_mkimage() (
	cd $GRUB_BUILDER_DIR
	# Create the memdisk filesystem. You get it for granted in the standalone version
	# Don't use mktemp, and leave the tarball for debugging if someone wants. This is not the best practice but if you run into issues with it
	# it is definitely "your fault" and you know what you are doing
	rm -rf /tmp/grub-memdisk-workdir/
	mkdir -p /tmp/grub-memdisk-workdir/boot/grub/
	cp $GRUB_CONFIG /tmp/grub-memdisk-workdir/boot/grub/grub.cfg
	( cd /tmp/grub-memdisk-workdir && tar cf /tmp/grub-memdisk.tar . && tar tf /tmp/grub-memdisk.tar )

	# grub-mkimage requires specifying modules explicitly
	# minicmd has help, lsmod etc. One could include help, but there is no module for lsmod
	: ${GRUB_MODULES="
		part_gpt part_msdos ext2 linux normal boot memdisk configfile search fat ls cat echo test gcry_dsa gcry_rsa gcry_sha256 pubkey pgp \
		tar minicmd efifwsetup
		tpm \
	"}
	./grub-mkimage -O x86_64-efi -o grubx64.efi --directory=./grub-core \
		--disable-shim-lock \
		--pubkey=$GRUB_PGP_PUBLIC_KEY \
		-m /tmp/grub-memdisk.tar \
		$GRUB_MODULES
)

build_standalone_image() (
	cd $GRUB_BUILDER_DIR
	./grub-mkstandalone -O x86_64-efi -o grubx64.efi --directory=./grub-core  \
		--modules="part_gpt part_msdos ext2 linux normal boot configfile search ls cat echo test gcry_dsa gcry_rsa gcry_sha256 pubkey pgp " \
		--fonts="" --locales="" --themes=""  \
		--disable-shim-lock \
		--pubkey $GRUB_PGP_PUBLIC_KEY \
		"boot/grub/grub.cfg=$GRUB_CONFIG"
)

#
# The idea here is to allow to chain multiple configuration fragments in the $REQUIRED_ARTIFACTS_DIR, and replace templated variables with
# environment variables.
# This can be done on the final file, but for now I'll do it in each file separtely.
# This file, will be $GRUB_CONFIG that the standalone images will create
#
update_grub_work_config() {
	if [ -z "$GRUB_CONFIGS" ] ; then
		echo "Please specify GRUB_CONFIGS. If you only have one configuration that is fine, but do specify it"
		exit 1
	fi

	printenv | grep ROOT

	local workdir=$REQUIRED_PROJECTS_ARTIFACTS_DIR/grub-config-work

	# Remove previous configs to not concatenate them without wanting
	rm -rf $workdir
	mkdir -p $workdir

	if [ -f $GRUB_CONFIG ] ; then
		# backup just in case
		mv $GRUB_CONFIG $GRUB_CONFIG.old
	fi

	echo "# Autogenerated by $0 on $(date)" > $GRUB_CONFIG
	if [ -n "$GRUB_DEFAULT_ENTRY" ] ; then
		# can also add more commands, via some environmnet files - although I would prefer that to be done with config fragments
		echo -e "\ndefault $GRUB_DEFAULT_ENTRY\n" >> $GRUB_CONFIG
	fi

	for f in ${GRUB_CONFIGS} ; do 
		echo "Copying GRUB config $f to $workdir and replacing template markers on it with environment variables"
		local newfile=$workdir/$(basename $f)
		cp $f $workdir
		replace_template_marker_with_env_value $newfile
		cat $newfile >> $GRUB_CONFIG
	done


	echo "DONE creating $GRUB_CONFIG"

       	: ${GRUB_DEBUG_CONFIG_FILE_BUILD=false}	
	if [ "$GRUB_DEBUG_CONFIG_FILE_BUILD" = "true" ] ; then
		echo "Your updated $GRUB_CONFIG is"
		cat $GRUB_CONFIG
	fi
}

build_grub_efi() {
	if [ "$GRUB_BUILD_STANDALONE" = "false" ] ; then
		echo "Non standalone building is not yet fully supported, and I don't know if it will be"
		build_nonstandalone_image
		return
	fi

	echo "Building GRUB EFI proper using $GRUB_BUILD_STANDALONE"
	if [ "$GRUB_BUILD_STANDALONE" = "grub-mkstandalone" ] ; then
		build_standalone_image
	elif [ "$GRUB_BUILD_STANDALONE" = "grub-mkimage" ] ; then
		build_standalone_image_with_mkimage
	else
		echo "Wrong mode. Exiting"
		return 1
	fi
}

build() (
	build_grub_core
	echo "Build done (grub-core). Please build a standalone (grub-mkstandalone or with the respective grub-mkimage flags) image. Only then, you may copy your artifacts from $GRUB_BUILDER_DIR/grubx64.efi"
	echo "The reason for that is to allow you to update your configurations (e.g. UUID's, and other things), and experiment with the set of GRUB modules you actually need"
	echo "If you want GRUB to be the default EFI boot app make sure you put in under the EFI System Partition's (ESP's) EFI/BOOT/BOOTX64.EFI file"
)

copy_artifacts() {
	cp $GRUB_BUILDER_DIR/grubx64.efi $REQUIRED_PROJECTS_ARTIFACTS_DIR
	# the grub config does not need to be copied because it is a single file that we already create in REQUIRED_PROJECTS_ARTIFACTS_DIR and has the same name
}


#
# Go for the template mark in the files ("@@somevar@@") and replace it with the value of the variable (e.g. ${somevar})
# Note: I am not sure it will work as is in bitbake, so if it is ported to a recipe, it will need to be tested
#
replace_template_marker_with_env_value() {
	INPUT_FILE="$1"

	if [ ! -f "$INPUT_FILE" ]; then
		echo "ERROR: file '$INPUT_FILE' not found"
		exit 1
	fi

	# bash smartness - !somevar is essentially  like eval "$var" but shorter. so the +whatever is whatever if $somevar is set
	# it's awkward but shorter to read
	for somevar in $(grep -o '@@[^@]\+@@' "$INPUT_FILE" | tr -d '@' | sort -u); do
		# Check if the environment variable is set
		if [ -z "${!somevar+whatever}" ]; then
			echo "ERROR: environment variable '$somevar' is not set"
			exit 1
		fi

   	 	# Replace all occurrences in the file
		sed -i "s|@@$somevar@@|${!somevar}|g" "$INPUT_FILE"
	done
}

main() {
	$1
}

main $@
