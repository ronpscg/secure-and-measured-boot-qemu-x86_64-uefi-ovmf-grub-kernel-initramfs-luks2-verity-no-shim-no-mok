#
# The idea here is to allow searching multiple disks and partitions for the existing of 
#
function set_root {
	disks="0 1 2 3 4 5 6 7"
	partitions="1 2 3"
	file_pattern_esp=/boot/bzImage.signed
	file_pattern_boot=/bzImage.signed

	# We look at the boot/ partition. If non exist there, and the materials exist in ESP we will use ESP either way
	found=false
	stop_after_first_found_boot_partition=true
   
	# ESP will be checked first, and is assumed to always be in the first partition of the first disk
	# Boot partitions will be preferred
	for d in $disks ; do 
		for p in $partitions ; do 
			if [ -e (hd$d,$p)/$file_pattern_esp ] ; then 
				echo "found Linux kernel in (hd$d,$p)"
				set root=(hd$d,$p)
				boot_materials_path=/boot/
			fi
			if [ -e (hd$d,$p)/$file_pattern_boot ] ; then 
				echo "found Linux kernel in (hd$d,$p)"
				echo "Not searching any more (if you have specific entries for A/B that want to override that, let them enjoy what they want"
				set root=(hd$d,$p)
				boot_materials_path=/
				if [ "$stop_after_first_found_boot_partition" = "true" ] ; then
					return
				fi
			fi
		done
	done
}

function boot_linux {
	insmod part_gpt
	insmod part_msdos
	insmod ext2
	if [ "$tpm" = "true" ] ; then
		echo "Will measure GRUB in TPM PCR #8"
		insmod tpm
	fi

	if [ -z "$rd_systemd_shell_options" ] ; then
		rd_systemd_shell_options="rd.shell SYSTEMD_SULOGIN_FORCE=1"
	fi

	set_root

	linux $boot_materials_path/bzImage.signed ro $console $rd_systemd_shell_options \
	root=@@KERNEL_CMDLINE_ROOT@@ \
	rd.luks.name=@@UUID_ROOTFS_ENC_IMG@@=@@LUKS_MAPPER_NAME@@ \
	systemd.verity_root_data=/dev/mapper/@@LUKS_MAPPER_NAME@@ \
	systemd.verity_root_hash=UUID=@@UUID_DMVERITY_ROOTFS_HASH_IMG@@ \
	roothash=@@DMVERITY_ROOT_HASH@@

	initrd $boot_materials_path/initrd.img
}

